import React, { useState, useMemo, useRef, useEffect } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import { Float, OrbitControls, PerspectiveCamera, Stars, Text, MeshDistortMaterial } from '@react-three/drei';
import { EffectComposer, Bloom, Vignette, Noise } from '@react-three/postprocessing';
import * as THREE from 'three';
import { animate } from 'framer-motion';

// --- 配置与常量 ---
const PARTICLE_COUNT = 8000;
const ORNAMENT_COUNT = 40;
const TREE_HEIGHT = 8;
const TREE_RADIUS = 3.5;

enum TreeState {
  TREE_SHAPE = 'TREE_SHAPE',
  EXPLODING = 'EXPLODING',
  SCATTERED = 'SCATTERED',
  REASSEMBLING = 'REASSEMBLING'
}

// --- 核心工具函数：生成树状坐标 ---
const getTreePosition = () => {
  const y = Math.random() * TREE_HEIGHT;
  const ratio = (TREE_HEIGHT - y) / TREE_HEIGHT;
  const radius = ratio * TREE_RADIUS;
  const angle = Math.random() * Math.PI * 2;
  return new THREE.Vector3(
    Math.cos(angle) * radius,
    y - TREE_HEIGHT / 2,
    Math.sin(angle) * radius
  );
};

const getScatteredPosition = () => {
  return new THREE.Vector3(
    (Math.random() - 0.5) * 20,
    (Math.random() - 0.5) * 20,
    (Math.random() - 0.5) * 20
  );
};

// --- 组件：针叶粒子层 (Shader) ---
const FoliageLayer = ({ state }: { state: TreeState }) => {
  const meshRef = useRef<THREE.Points>(null!);
  
  const [positions, treePos, scatterPos] = useMemo(() => {
    const p = new Float32Array(PARTICLE_COUNT * 3);
    const t = new Float32Array(PARTICLE_COUNT * 3);
    const s = new Float32Array(PARTICLE_COUNT * 3);
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const tp = getTreePosition();
      const sp = getScatteredPosition();
      t.set([tp.x, tp.y, tp.z], i * 3);
      s.set([sp.x, sp.y, sp.z], i * 3);
      p.set([tp.x, tp.y, tp.z], i * 3);
    }
    return [p, t, s];
  }, []);

  useFrame((_, delta) => {
    const posAttr = meshRef.current.geometry.attributes.position;
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const ix = i * 3;
      const current = new THREE.Vector3(posAttr.array[ix], posAttr.array[ix+1], posAttr.array[ix+2]);
      const target = state === TreeState.TREE_SHAPE || state === TreeState.REASSEMBLING 
        ? new THREE.Vector3(treePos[ix], treePos[ix+1], treePos[ix+2])
        : new THREE.Vector3(scatterPos[ix], scatterPos[ix+1], scatterPos[ix+2]);
      
      // 平滑插值模拟缓动
      current.lerp(target, delta * (state === TreeState.EXPLODING ? 1 : 3));
      posAttr.setXYZ(i, current.x, current.y, current.z);
    }
    posAttr.needsUpdate = true;
  });

  return (
    <points ref={meshRef}>
      <bufferGeometry>
        <bufferAttribute attach="attributes-position" count={PARTICLE_COUNT} array={positions} itemSize={3} />
      </bufferGeometry>
      <pointsMaterial 
        size={0.05} 
        color="#A8BBA1" 
        transparent 
        opacity={0.6} 
        blending={THREE.AdditiveBlending}
        sizeAttenuation 
      />
    </points>
  );
};

// --- 组件：加权实例化装饰物 ---
const Ornaments = ({ state }: { state: TreeState }) => {
  const meshRef = useRef<THREE.InstancedMesh>(null!);
  const tempObject = new THREE.Object3D();
  
  const data = useMemo(() => {
    return Array.from({ length: ORNAMENT_COUNT }, () => ({
      treePos: getTreePosition(),
      scatterPos: getScatteredPosition(),
      velocity: new THREE.Vector3(),
      weight: Math.random() > 0.7 ? 1.5 : 0.5, // 1.5 重型，0.5 极轻
      rotSpeed: new THREE.Vector3(Math.random(), Math.random(), Math.random())
    }));
  }, []);

  useFrame((_, delta) => {
    data.forEach((item, i) => {
      if (state === TreeState.EXPLODING) {
        // 物理炸裂逻辑
        const force = item.treePos.clone().normalize().multiplyScalar(delta * 20 / item.weight);
        item.velocity.add(force);
        item.scatterPos.add(item.velocity);
        item.velocity.multiplyScalar(0.95); // 阻尼
        tempObject.position.copy(item.scatterPos);
        tempObject.rotateX(item.rotSpeed.x * delta);
      } else if (state === TreeState.TREE_SHAPE || state === TreeState.REASSEMBLING) {
        // 聚合逻辑
        const currentPos = new THREE.Vector3();
        const m = new THREE.Matrix4();
        meshRef.current.getMatrixAt(i, m);
        currentPos.setFromMatrixPosition(m);
        currentPos.lerp(item.treePos, delta * 2);
        tempObject.position.copy(currentPos);
        tempObject.rotation.set(0, 0, 0);
      } else {
        // SCATTERED 缓慢漂浮
        item.scatterPos.y += Math.sin(Date.now() * 0.001 + i) * 0.002;
        tempObject.position.copy(item.scatterPos);
      }
      
      tempObject.updateMatrix();
      meshRef.current.setMatrixAt(i, tempObject.matrix);
    });
    meshRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[undefined, undefined, ORNAMENT_COUNT]} castShadow>
      <sphereGeometry args={[0.15, 16, 16]} />
      <meshStandardMaterial color="#F1C40F" emissive="#F1C40F" emissiveIntensity={2} roughness={0.1} />
    </instancedMesh>
  );
};

// --- 主场景组件 ---
export default function App() {
  const [state, setState] = useState<TreeState>(TreeState.TREE_SHAPE);

  const toggleState = () => {
    if (state === TreeState.TREE_SHAPE) {
      setState(TreeState.EXPLODING);
      setTimeout(() => setState(TreeState.SCATTERED), 2000);
    } else {
      setState(TreeState.REASSEMBLING);
      setTimeout(() => setState(TreeState.TREE_SHAPE), 2000);
    }
  };

  return (
    <div style={{ width: '100vw', height: '100vh', background: '#050505' }}>
      <div style={{ position: 'absolute', top: 40, left: 40, zIndex: 10, color: '#E0E5D8' }}>
        <h1 style={{ fontSize: '1.5rem', fontWeight: 'lighter', letterSpacing: '4px' }}>ARIX SIGNATURE</h1>
        <p style={{ opacity: 0.5 }}>Interactive Christmas 2025</p>
        <button 
          onClick={toggleState}
          style={{
            marginTop: '20px',
            padding: '10px 20px',
            background: 'transparent',
            border: '1px solid #F1C40F',
            color: '#F1C40F',
            cursor: 'pointer',
            borderRadius: '20px'
          }}
        >
          {state === TreeState.TREE_SHAPE ? "EXPLODE" : "REASSEMBLE"}
        </button>
      </div>

      <Canvas shadows gl={{ antialias: false }}>
        <PerspectiveCamera makeDefault position={[0, 5, 15]} fov={35} />
        <OrbitControls enableZoom={false} autoRotate={state === TreeState.SCATTERED} autoRotateSpeed={0.5} />
        
        <color attach="background" args={['#0a0d0a']} />
        <fog attach="fog" args={['#0a0d0a', 10, 25]} />

        <ambientLight intensity={0.4} />
        <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} intensity={1000} castShadow />

        <group position={[0, -2, 0]}>
          <FoliageLayer state={state} />
          <Ornaments state={state} />
          
          {/* 树干核心 */}
          {state === TreeState.TREE_SHAPE && (
             <mesh position={[0, TREE_HEIGHT/2 - 0.5, 0]}>
               <cylinderGeometry args={[0.05, 0.2, TREE_HEIGHT, 12]} />
               <meshStandardMaterial color="#2d3436" transparent opacity={0.3} />
             </mesh>
          )}
        </group>

        <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />

        <EffectComposer>
          <Bloom luminanceThreshold={0.2} mipmapBlur intensity={1.2} radius={0.7} />
          <Noise opacity={0.05} />
          <Vignette eskil={false} offset={0.1} darkness={0.8} />
        </EffectComposer>
      </Canvas>
    </div>
  );
}